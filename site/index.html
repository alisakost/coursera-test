<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Coursera is cool</title>
	<style type="text/css">
		
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: Arial, sans-serif;
			line-height: 1.5;
			margin: 40px 150px;
		}

		p {
			margin-bottom: 15px;
		}

		table {
			border-collapse: collapse; /*Убирает отсутпы между ячейками таблицы*/
		}
		td, th {
			padding: 10px;
			border: 1px solid black;
		}
		img {
			width: 70%;
		}
		table.center {
			text-align: center;
		}
		#float {
			background: lightblue;
		}
		#float-group p {
			float: left;
			width: 50px;
			height: 50px;
			border: 1px solid black;
			margin-left: 10px;
		}
		#p1 {
			background-color:  red;
		}
		#p2 {
			background-color:  blue;
		}
		#p3 {
			background-color:  green;
			clear: left;
		}
		#p4 {
			background-color:  yellow;
		}
		#float-section {
			clear: left;
			margin-left: 10px;
		}
		#two-column {
			background-color: skyblue;
		}
		#p5, #p6 {
			width: 50%;
			border: 1px solid black;
			float: left;
			padding: 20px;
		}
		#p5 {
			background-color: red;
		}
		#p6 {
			background-color: green;
		}
		h1, h2, h3, h4 {
			margin-top: 40px;
			margin-bottom: 15px;
		}
		.blue-cont {
			background-color: lightblue;
			position: relative;
			top: 15px;
		}
		.rel {
			width: 50px;
			height: 50px;
			border: 1px solid black;
			margin-bottom: 15px;
		}
		.rel.one {
			background-color: red;
			position: relative;
			top: 65px;
			left: 65px;
		}
		.rel.two {
			background-color: blue;
		}
		.rel.three {
			background-color: green;
		}
		.rel.four {
			background-color: yellow;
		}
		.rel.abs.three {
			position: absolute;
			top: 0;
			left: 0;
		}

		/*Responsive Layout Example*/
		p.resp {
			border: 1px solid black;
  		background-color: #A52A2A;
  		width: 90%;
 		 	height: 150px;
  		margin-right: auto;
  		margin-left: auto;
  		color: white;
  		padding: 10px;
		}

		/* Simple Responsive Framework. */
		.row {
  		width: 100%;
		}

		/********** Large devices only **********/
		/*Здесь я прописываю все значения для всех типов колонок, чтобы в будующем просто вписывать название класса и не запариваться со стилями*/
	@media (min-width: 1200px) {
  .col-lg-1, .col-lg-2, .col-lg-3, .col-lg-4, .col-lg-5, .col-lg-6, .col-lg-7, .col-lg-8, .col-lg-9, .col-lg-10, .col-lg-11, .col-lg-12 {
    float: left;
    border: 1px solid green;
  }
  .col-lg-1 {
    width: 8.33%;
  }
  .col-lg-2 {
    width: 16.66%;
  }
  .col-lg-3 {
    width: 25%;
  }
  .col-lg-4 {
    width: 33.33%;
  }
  .col-lg-5 {
    width: 41.66%;
  }
  .col-lg-6 {
    width: 50%;
  }
  .col-lg-7 {
    width: 58.33%;
  }
  .col-lg-8 {
    width: 66.66%;
  }
  .col-lg-9 {
    width: 74.99%;
  }
  .col-lg-10 {
    width: 83.33%;
  }
  .col-lg-11 {
    width: 91.66%;
  }
  .col-lg-12 {
    width: 100%;
  }
}

/********** Medium devices only **********/
@media (min-width: 950px) and (max-width: 1199px) {
  .col-md-1, .col-md-2, .col-md-3, .col-md-4, .col-md-5, .col-md-6, .col-md-7, .col-md-8, .col-md-9, .col-md-10, .col-md-11, .col-md-12 {
    float: left;
    border: 1px solid green;
  }
  .col-md-1 {
    width: 8.33%;
  }
  .col-md-2 {
    width: 16.66%;
  }
  .col-md-3 {
    width: 25%;
  }
  .col-md-4 {
    width: 33.33%;
  }
  .col-md-5 {
    width: 41.66%;
  }
  .col-md-6 {
    width: 50%;
  }
  .col-md-7 {
    width: 58.33%;
  }
  .col-md-8 {
    width: 66.66%;
  }
  .col-md-9 {
    width: 74.99%;
  }
  .col-md-10 {
    width: 83.33%;
  }
  .col-md-11 {
    width: 91.66%;
  }
  .col-md-12 {
    width: 100%;
  }
}

	</style>
</head>
<body>
<h1>Coursera: HTML + CSS + JS</h1>
<p id="section1">Всегда используйте языковой атрибут <b>lang</b> тэга html для объявления языка по умолчанию на странице. Если страница содержит контент на другом языке, добавляйте языковой атрибут к элементам, окружающим этот контент. </p>
<p>Все элементы можно поделить на 2 категории: <b>Block-level elements</b> и <b>Inline Elements</b>.</p>
<table style="text-align: left;">
	<tr>
    <th>Block-level elements</th>
    <th>Inline Elements</th>
   </tr>
   <tr><td style="padding-right: 30px;" width="400px">Отображаются, начиная с новой строки (по умолчанию, можно изменить в CSS)</td><td>Отображаются на одной строке (по умолчанию).</td></tr>
   <tr><td style="padding-right: 30px;" width="400px">Могут содержать в себе inline elements или другие block-level elements.</td><td>Могут содержать в себе только другие inline-elements</td></tr>
   <tr><td style="padding-right: 30px;" width="400px">Roughly Flow Content (HTML5 Category)</td><td>Roughly Phrasing Content (HTML5 Category)</td></tr>
</table>
<br>
<div>Div – деление. Самый общий block элемент. Он не может быть вложен в span</div>
<div>Div – Самый общий block элемент. Он требует своей собственной строки.</div>
<span>Span – диапозон, интервал. Самый общий inline элемент. Если он идет после div, то все равно перенесется на новую строку, как тут.</span>
<div>
	** Вот что будет, если поместить span внутри div: **
	<span>** Это текст внутри span, он идет в строку **</span>
	** Это текст после span, который просто внутри div. **
</div>
<br>
<div><a href="https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html">По данной ссылке</a> можно посмотреть разные категории моделей содержимого HTML5. Например: <img src="/Users/panteleymon/coursera-test/site/content.png" width="70%"></div>
<br>
<h2><a name="section2">Semantic tags</a></h2>
<div><b>Semantic Tags</b> – это то, что помогает SEO. Например <b>h1-h6</b> элементы. Если не использовать заголовки, а использовать div, то потеряется смысл заголовка. H1 должен передавать центральную тему основного содежрания и он очень важен для SEO оптимизации. Правильно подобранный контент для этого тега может играть решающее значение.</div>
<br>
<div><b>Header тег</b> содержит инфу о содержании страницы: лого компании, теги, навигация
<br><b>Nav</b> означает содежимое, использующееся для навигации внутри сайта
<br>Есть также <b>Section</b> и <b>Article</b>, которые могут вкладываться друг в друга
<br><b>Aside тег</b> означает содержание, которое относится к содержимому главной темы, но не как прямая связь, например, related posts.
<br><b>Footer тег</b> имеет инфу нижнего колонтитула. Copyright и т.д.</div>
<br>
<div>Это все элементы <b>block level</b>, кроме <b>nav</b>.</div>
<div>Вместо всех этих тегов легко можно было бы использовать div, но код с разнообразными тегами легче читать и понимать, что происходит на структурной основе HTML страницы. Их использование может повлиять как на SEO ranking of the page, так и на понимание страницы не только людьми, но и компьютерами.</div><br>
<p>Lists позволяют группировать контент. Часто используются для структурирования навигационных частей страницы. <b>ul</b> - unordered list. <b>ol</b> - ordered list. <b>li</b> - list item.</p>
<div>
	<ul>
		<li>Молоко</li>
		<li>Пончики</li>
		<li>Печеньки
			<ul> <!-- Подпсписок -->
				<li>Шоколад</li>
				<li>Сахар</li>
			</ul>
		</li>
		<li>Картошка</li>
	</ul>

	<ol>
		<li>Откртыть печеньки</li>
		<li>Достать их</li>
		<li>Сложить их вместе
			<ol> <!-- Подпсписок -->
				<li>Снять верхнюю часть</li>
				<li>Положить на нее другую печеньку</li>
			</ol>
		</li>
		<li>Съесть это</li>
	</ol>
</div>
<h2>
	HTML Character Entity References
</h2>
<p>These 3 characters should always be escaped: "<", ">", "&".</p>
<table><tr>
   <tr><td><b>Вместо этого</b></td><td><</td><td>></td><td>&</td></tr>
   <tr><td><b>Использовать это (см. код)</b></td><td>&lt;</td><td>&gt;</td><td>&amp;</td></tr>
<p>Это позволит браузеру интерпретировать символы не как код, а как контент.</p>
</table>
<p>Copiright можно записать кодом как &copy; (см. код)<br>
Неразрываемы&nbsp;пробел&nbsp;записывается&nbsp;так (см. код). Non-broken space – nbsp. С помощью него также можно создавать несколько&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;пробелов, но это <b>неправильно</b>. Вместо этого надо применять margin в css.</p>
<p>" можно заменить с помощью &quot;. quot помогает, если при ограниченной кодировке (не utf-8, а другой) кавычки заменяются странными символами.</p>
<h2>Creating links</h2>
<p id="section 1">Есть внутренние и внешние ссылки. Ссылки делаются с помощью тега "а". Значение его атрибута href может быть как относительным, так и абсолютным URL адресом. Для внутренних ссылок можно использовать и относительные URL ссылки (same-directory.html), и абсолютные (https://www.facebook.com/). Если не представить информации о директории относительной ссылки, браузер будет считать, что она расположена там же, где и основной документ. Также лучше указывать атрибут <b>Title</b> для тега "а", они используются скринридерами и помогают людям с нарушениями зрения изучать страницу.</p>
<p>В тег "a" может быть заключен div. Это нужно, чтобы иметь возможность кликнуть по целому региону (лого и пр.), а не надписи. Он также по умолчанию заставит контент перейти на новую строку.</p>
<p>Внешние ссылки часто включают атрибут 'target'. Например target="_blank" заставляет браузер открыть стр. в новом окне или вкладке.</p>
<p>Есть также тип ссылки, который является идентификатором фрагмента. Например, <b>a href="#section1"</b>. Они указывают на разделы страницы. Чтобы ими пользоваться, надо иметь раздел с <b>id="section1"</b>. Id не содержит символа #, который содержит ссылка. <br>Также это может быть якорный тег, который содержит name атрибут <b>name="section1"</b>.</p>
<div><a href="#section1">Начало документа (id)</a>
<a href="#section2">Semantic tags (якорь через name)</a></div>
<p>Такая навигация часто используется в SPA (Single Page Applications).</p>
<h2>Displaying images</h2>
<p>img tag имеет атрибут src – он также может быть относительным или абсолютным, width и height должны быть указаны обязательно, <b>иначе, браузер не забронирует это место для изображения при загрузке, и картинка будет некрасиво прыгать.</b>. А если сломается url, визуальный layout все равно сохранится, если указать width и height. img - inline element.</p>
<h2>Anatomy of a CSS Rule</h2>
<p>CSS имеет селектор (то, чему задается стиль, например p { ... 
	<br>color - property, blue - value. Stylesheet – файл со всеми этими стилями. Style можно запихнуть в head документа в теги style, но проще подключить другой документ.</p>

<h2>Element, Class, and ID Selectors</h2>
<p>Element – просто указания имени. Например, "p" <br>
Class – ".blue" в CSS и class="blue" в HTML<br>
Id – "#mainPoint" в CSS и id="mainPoint" в HTML. <b>Регистр букв имеет значение</b> <br>
Grouping Selectors: div, .blue
<br><b>Id элемент самый немногоразовый. Один и тот же ID Value может отображаться в HTML документе только 1 раз.</b></p>

<h2>Combining Selectors</h2>
<h3>Element with Class Selector</h3>
<p>Эта техника помогает нацелиться на немые элементы. Например, "p" с class селектором: <br> p.big { <br>
font-size: 20px; <br>
}</p>
<p>Если я поставлю пробел между p.big, это будет означать уже другую комбинацию, а не каждый p с классом big.</p>
<h3>Child Selector</h3>
<p>article > p {<br> color: blue; <br> }</p>
<p>Эта комбинация читается справа налево. Это означает таргет на каждый "p", который является прямым (direct) дочерним элментом "article". <br> Например, текст в < article >< p >< div > ... < /div >< /p >< article > не будет синим, потому что здесь текст не в прямом дочернем элементе, а в div. </p>
<h3>Descendant (Поточный) Selector</h3>
<p>article p { <br> color: blue;<br>}</p>
<p>Комбинация также читается справа налево. Означает таргет на каждый "p", который находится внутри "article" <b>на любом уровне</b>. Таким образом, ему необязательно быть direct chield.</p>
<h3>Not Limited to Element Selectors</h3>
<p>Селекторы никак не ограничены и может быть много комбинаций, например:</p>
<p>.colored p { <br>color: blue; <br>}</p>
<p>Читается справа налево. Означает, что каждый "p" элемент, который находится на любом уровне элемента с class="colored", будет иметь голубой цвет.</p>
<br>
<p>article > .colored { <br>color: blue; <br>}</p>
<p>Читается справа налево. Означает, что каждый элемент с class="colored", который является прямым дочерним элементом элемента "aricle", будет иметь голубой цвет.</p>
<h3>Применение нескольких классов к элементу</h3>
<p>Чтобы применить несколько классов к одному элементу, нужно просто написать их через пробел без запятых: <b>div class="mainpoint highlight"</b></p>

<h3>Стили для нескольких классов</h3>
<p>.highlight.mainpoint { <br>color: red; <br>}</p>
<p>Это пишется без пробела, стиль применится к тому элементу, который имеет <b>оба класса</b> (не каждый по отдельности).</p>

<h3>Adjacent Sibling Selector (Смежные селекторы)</h3>
<p>li:first-of-type + li { <br>
  color: red; <br>
}</p>
<p>Указывает на смежный или следующий селектор. Обеспечивает выбор только элемента расположенного непосредственно за определённым в первой части элементом.</p>
<p>Таким образом, в коде <br>
< ul ><br>
  < li >Один< /li ><br>
  < li >Два< /li ><br>
  < li >Три< /li ><br>
< /ul ><br>
красным будет только "Два".
<p><ul>
  <li>Один</li>
  <li style="color: red;">Два</li>
  <li>Три</li>
</ul>
</p>
</p>
<h3>General Sibling Selector (Селектор следующего элемента)</h3>
<p>p ~ span { <br>
  color: red; <br>
}</p>
<p>Разделяет 2 селектора и находит 2-й элемент только если перед ним есть 1-й, и они оба имеют общего родителя. Свойства будут применены ко всем элементам, указанным в правой части, следующими за элементом, указанным в левой части.</p>
<p>
< span >Это не красный.< /span > <br>
< p >Здесь параграф.< /p > <br>
< code >Тут какой-то код.< /code ><br>
< span > <span style="color: red;"> А здесь красный, потому что он идет после "p". </span>< /span >
</p>

<h2>Pseudo-Class Selectors</h2>
<p>Примеры псевдо-класс селекторов: <br>
:link (стиль ссылки), :visited (стиль посещенной ссылки), :hover (наведение), :active (нажато, но еще не отпущено), :nth-child(...) и прочие</p>
<p>Не по теме: block элементы по умполчанию заполняют все пространство в строке, которое они могут заполнить. Поэтому если сделать им background-color, он заполнит всю строку.</p>
<p>nth-chlid(...) позволяет таргетироваться на конкретный элеменент по номеру, например: <br> <br>
header li:nth-chlid(3) { <br>
color: red; <br>
}</p>
<p><b>section div:nth-chlid(odd)</b> будет таргетироваться только на нечетные пункты div</p>
<p>Псевдо-селекторы могут быть комбинированы, как и обычные селекторы. Например: <br>
<b>section div:nth-child(4):hover</b> будет таргетироваться только на 4-й div при наведении</p>
<p>a:hover div:nth-child(5) {  <br>
  font-size: 24px; <br>
} <br>
Данный код будет менять размер шрифта Div 5, когда мышь наведена <b>на любую зону "a" элемента.</b></p>
<h2>Style Placement</h2>
<p>В head, непосредственно в элементе (inline styling), внешние таблицы стилей: <br>
< link rel="stylesheet" href="style.css" > <br>
stylesheet должен располагаться <b>в той же директории, что и index.html файл.</b></p>
<h2>Conflict Resolution</h2>
<h3>Some Concepts</h3>
<table>
	<tr>
    <th>origin</th>
    <th>merge</th>
   </tr>
   	<tr>
    <th>inheritance</th>
    <th>specificity</th>
   </tr>
</table>
<h3>Origin Precedence – Приоритет происхождения (when in conflict)</h3>
<p><b>Правило:</b> Последнее объявление выигрывает. Так как HTML отображается последовательно сверху вниз, так что <b>чем ниже код на странице, тем больше их приоритет.</b> Если это внешний CSS, то надо просто представить, что он взят и полностью скопирован в head, то есть он вверху.</p>

<h3>Merge (when no conflict)</h3>
<p>Если на один элемент нацелены разные CSS свойства (например, цвет и размер) из разных источников, то они просто сольются в один, т.к. конфликта нет.</p>

 <h3>Inheritance – Наследование</h3>
 <p>Есть Document Object Model (DOM) Tree, в котором все дети и дети этих детей заданного элемента будут наследовать свойства этого элемента.</p>
 <img src="dom-tree.png">

 <h3>Specificity</h3>
 <p><b>Правило:</b> Наиболее специфическая комбинация селекторов выигрывает.</p>
<div>Таким образом, селекторы с наибольшим счетом считаются более конкретными (слева направо – самые специфичные к менее специфичным). <br> Чтобы посчитать счет, надо взять код и посмотреть сколько раз определенный селектор используется в правильном месте. <br><br>
<table class="center">
	<tr>
		<td>style="..."</td><td>ID</td><td>Class, pseudo-class, attribute</td><td># (потомки) of Elements</td>
	</tr>

	<tr><td colspan="4">< h2 style="color: green; ></td></tr>
	<tr><td>1</td><td>0</td><td>0</td><td>0</td></tr>

	<tr><td colspan="4">div p { color: green; }</td></tr>
	<tr><td>0</td><td>0</td><td>0</td><td>2</td></tr>

	<tr><td colspan="4"><b>Кто победит?</b></td></tr>
	<tr><td colspan="4">div #myParag { color: blue; }</td></tr>
	<tr><td>0</td><td>1</td><td>0</td><td>1</td></tr>
	<tr><td colspan="4">Итого счет 101</td></tr>
	<tr><td colspan="4">div.big p { color: green; }</td></tr>
	<tr><td>0</td><td>0</td><td>1</td><td>2</td></tr>
	<tr><td colspan="4">Итого счет 12</td></tr>
	<tr><td colspan="4"><b>Победил синий цвет</b></td></tr>
</table><br>
<b>Для этой победы можно было не конкретизировать код с помощью div, а обойтись только #myParag</b>
</div>
<p>Предопределить все эти правила помогает <b>!important</b>. Даже если у применяемого правила всего одно очко, оно выиграет с этим обозначением. Но использовать это нужно <b>в крайнем случае, когда без этого не обойтись</b></p>
<h2>Styling Text</h2>
<p>Причина, по которой я в <b>font-family</b> указываю не только один шрифт, а несколько, заключается в в том, что когда я указываю семейство шрифтов таким образом, я полагаюсь на компьютер пользователя и на то, что <b>на нем установлены это шрифты</b>. И таким образом я предоставляю несколько опций.</p>
<p> p { font-family: "Times New Roman", Times, serif; }</p>
<p>В коде цвета <b>#0000ff</b> первые 2 цифры - red, вторые 2 – green, третие 2 – blue. <b>ff – самое высокое значение</b>.</p>
<p>Почти каждый браузер имеет размер шрифта по умолчанию <b>16 px</b>.</p>
<h3>Relative Font Sizing</h3>
<p><b>font-size: 120%</b> означает, что надо взять размер шрифта, который бразуер предоставляет по умолчанию (16px, например), и увеличить его на 120%. То есть это будет немного больше 19px. <b>Часто % применяется ко всему документу, т.е. к тегу body.</b></p>
<p><b>font-size: 2em</b> – em – это единица измерения, которая эквивалентна ширине буквы "m" в этом конкретном шрифте. <b>Это относительный размер</b>. И если комбинировать его со 120%, которые были заданы родительскому тегу, то мы <b>увеличим шрифт в 2 раза от того, что было 120%</b>. То есть 120% не переопределяет 2em, а играет вместе с ним, потому что 2em относительный. То же самое em сделает с px, несмотря на то, что они – абсолютные. А если я хочу сделать дочерний 2em тег размером 4em, мне нужно прописать в нем также 2em, потому что они умножатся. Технически 2em = 200%. Однако более распространенная практика – это использование именно em внутри самих документов, а не тега body.</p>
<p>Если я хочу уменьшить 4em до 2em, в могу ввести в дочернем теге <b>.5em</b>, что уменьшит его в 2 раза.</p>
<p>Несмотря на то, что % используются в body, <b>не рекомендуется смешивать %, em и px в документах</b>, иначе будет беспорядок.</p>
<p>Несмотря на то, что  120% размер текста указан в body, <b>пользователь может сделать то же самое, просто увеличив масштаб</b>. При этом визуальные отношения размеров шрифтов (если они были указаны относительными единицами), <b>останутся теми же</b>.</p>

<h2>The Box Model</h2>
<p>В HTML каждый элемент считается коробкой. У каждой коробки есть (в таком порядке): padding, border, margin.</p>
<p>По умолчанию браузеры часто ставят тегу body какой-то margin, но его можно сбрасывать, если нужно.</p>
<p>В записи margin: 10px 10px 10px 10px значения идут начиная сверху по часовой стрелке: верх, право, низ, лево.</p>
<p><b>Padding</b> дает некоторое заполнение вокруг контента, которое также примет значения этого контента, например, цвет. Потому что это буквально расширяет поле контента.</p>
<p><b>Border</b> будет идти вокруг padding, т.е. вокруг контента.</p>
<p><b>Margin</b> дает отступы вокруг всего контента вместе с padding и border.</p>
<p>Если у контента с width 300px указать padding 10px с каждой стороны + border 5 px с каждой стороны, получится коробка шириной 330px. Таким образом, <b>width – это свойство только контента, а не всей коробки</b>.</p>
<p>Однако существует <b>box-sizing: border-box, который говорит, что вся коробка должна принять свойство width</b>.</p>
<p>Чтобы вернуть все к значению по умолчанию, надо поставить <b>box-sizing: content-box</b>.</p>
<p style="color: red;"><b>Современные фреймворки, например, Bootstrap, используют border-box как sizing model.</b> Поэтому когда я работаю со своими макетами, мне также надо установить везде border-box. Но это свойство не наследуется. Чтобы обойти это, надо установить star selector:</p>
<p>* { box-sizing: border-box; } </p>
<p>* говорит коду идти и применить эти свойства к каждому элементу, который у нас есть. Ее отличие от родительского селектора, например, body, в том, что * <b>не просит наследовать что-либо</b>, а говорит применить свойства к каждому элементу, будто бы они были в них вписаны вручную.</p><br>
<h3>caniuse.com</h3>
<div>Сайт, на котором можно проверять, все ли браузеры поддерживают какие-либо свойства.</div> <br>

<h3>Cumulative Margins (Кумулятивные)</h3>
<p>Поля <b>слева направо</b> являются кумулятивными. Это значит, что они складываются и играют вместе. То есть если у двух коробок в одной линии стоит margin left 40px и margin right 50px, между ними будет margin = 90px.</p>
<h3>Margins Collapse</h3>
<p><b>Верхние и нижние поля</b> не являются кумулятивными, и они схлопнуться, и крупнейшая маржа победит. То есть если margin bottom 20px и margin top 30px, то маржа между двумя коробками друг над другом будет просто 30px.</p>

<h3>Изначальные установки браузера</h3>
<p>Помимо простого margin, бразуер может предопределять <b>-webkit-margin-before и -webkit-margin-after</b>, которые не обнуляться, если в body установить значение margin: 0. Потому что в таком случае body говорит, что все элементы будут наследовать это свойство в том случае, если для какого-то элемента оно не будет специально переопределено. Таким образом, если margin-before или margin-after были указаны специально для селектора h1, они не обнулятся. <b>Таким образом, margin: 0 можно просто записать в star selector ( * ).</b> Это называется CSS Resetting (сброс настроек CSS по умолчанию), и в основном для этого всегда используется * selector.</p>
<p>Если при box-sizing: border-box указать height, который меньше высоты контента, контент просто "вытечет" из коробки. С этим поможет справиться <b>overflow</b>. При свойстве <b>hidden</b> контент просто будет обрезаться там, где заканчивается коробка. <b>Visible</b> – это свойство по умолчанию, когда он вытекает. <b>Auto</b> – скрыть и проложить scrollbars везде, где они нужны, чтобы можно было посмотреть весь контент. <b>Scroll</b> позволят держать ползунки прокрутки видимыми вне зависимости от того, нужны они или нет (в том числе горизонтальный скролл, даже если он не нужен).</p>
<p><b style="color: red;">НО! Пользователи ненавидят двойную прокрутку. Использовать это только там, где реально необходимо.</b></p>

<h2>The background Property</h2>
<p><b>background-image: url("image.png")</b> – так сделать фон картинку. Важно: url должен быть относителен файлу CSS и тому, как CSS подается в браузере.</p>
<p><b>background-repeat: no-repeat</b> или другие свойства позволяют контролировать повторяется изображение в данной области или нет.</p>
<p>background-image и backgrpund-color могут использоваться вместе и background-image будет выигрывать в приоритете: он будет вверху.</p>
<p><b>background-position: top right</b> – позиция фонового изображения в формате горизонтального + вертикального значения. Если указать только один из них, другой по дефолту будет считаться центром.</p>
<p style="color: red;"><b>Все эти индивидуальные свойства можно объединить в одно общее:</b></p>
<p><b>background: url("image.png") no-repeat right center blue;</b> – просто надо указывать их один за другим. Если указать что-то в теге background, а что-то в теге в формате background-something, один из тегов перепишет другой (в зависимости от того, какой будет находиться ниже в коде). <b>Если при использовании тега background, который находится ниже тега в формате background-something я не укажу конкретной свойство, оно не будет зайдествовано вообще, даже если в background-something оно было задано.</b></p>

<h2>Positioning Elements by Floating</h2>
<p>Большинство UI сегодня сделаны с помощью floating elements.</p>
<p><b>floar: right</b> перемещает элемент в правый край содержащего элемента. Допустим, если 'p' находился внутри 'div', он уедет в правый верхний конец этого div. При этом элементы, которые находились под ним слева, подвинутся наверх на его исходное место. Причина в том, что когда я float элементы, <b>браузер исключает их из обычного потока документов.</b>Если у нижних элементов была маржа, она коллапснится, когда она каснется поля другого элемента. Однако у того элемента, который был floated, <b>margin никогда не разрушается.</b></p>
<p>Если все 'p' внутри одного 'div', которые изначально были расположены с новых строк друг над другом, сделать <b>float: left</b>, они будут идти в строку друг за другом, а размер контейнера div уменьшится до размера других элементов, расположенных в нем, так как <b>float элементы из него вылетят, и будут просто плавать слева от всего контента</b>.</p>
<p>Чтобы исправить это, нужно сказать браузеру, что нижний элемент внутри div не разрешает ничему плавать слева от него:</p>
<p>
	< div > <br>
	< p id="p1" >< /p ><br>
	< p id="p2" >< /p ><br>
	< p id="p3" >< /p ><br>
	< p id="p4" >< /p ><br>
	< section > Какой-то текст < /section ><br>
	< /div >
</p>
<p>p { float: left; } <br>
section { clear: left; }</p>
<p>Таким образом, свойство <b>claer: left;</b> говорит, что section должен быть под p, а не справа от них, потому что он не разрешает ничему плавать слева от него.</p>
<p><b>Пример:</b></p>
<div id="float">
	<div id="float-group">
	<p id="p1"></p>
	<p id="p2"></p>
	<p id="p3"></p>
	<p id="p4"></p>
	</div>
	<section id="float-section">Какой-то текст для примера того, как запрещать float элементам плавать слева от него</section>
</div>

<p>Таким образом, если задать clear: left третьей коробке, то она переместится на новую строку вместе с четвертой коробкой.</p>
<p><b>clear: both</b> позволяет гарантировать, что если есть два элемента, у одного из которых стоит float: left, а у другого float: right, ни один из них не посягнет на пространство элемента, у которого задан clear: both</p>

<h3>Two Column Layout Design</h3>
<div id="two-column">
<p id="p5">Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
<p id="p6">It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</p>

<section>Это пример дизайна с двумя колонками с помощью свойства float: left. Важно чтобы их настройки ширины были заданы таким образом, чтобы они помещались по ширине на одну строку. Иначе вторая колонка сползет вниз на новую сторку. Для этого нужно установить <b>width: 50%</b>, но если есть padding и/или border, убедиться, что <b>box-sizing: border-box</b></section>
</div>

<h2>Relative and Absolute Element Positioning</h2>
<h3>Static Positioning</h3>
<p>Normal doc flow. Default for all, except html.</p>
<p>Если попытаться применить смещения позиционирования к элементам, чей position: static, <b>смещения просто будут игнорироваться.</b></p>

<h3>Relative Positioning</h3>
<p>Relative to element's position in normal doc flow.</p>
<p>Если применить смещение (offset) к этому элементу, произойдет смещение <b>от исходной нормальной позиции элемента в потоке документа.</b></p>
<h4>Positioning CSS (offset) properties are:</h4>
<p>top, bottom, left, right</p>
<p>Таким образом, границы элемента сверху, снизу, слева и справа становятся <b>границами, от которых я смещаю элемент</b>.</p>
<p>Элемент, который установлен на relative position <b>не вынимается из нормального потока документов.</b> Даже если он перемещается с помощью смещений, его <b>original spot сохраняется.</b> То есть относительно всех осталньых элементов HTML, этот элемент все еще сидит на своем первоначальном месте, хотя визуально он где-то в другом месте.</p>
<p><b>p { position: relative; top: 50px; left: 50px; }</b> будет означать, что сверху вниз элемент сместится на 50px и слева направо на 50px от своего изначального положения в документе. При этом фактически его изначальное место в документе будет все еще закреплено за ним. Таким образом, <b>все элементы вокруг этого элемента останутся на своих местах, потому что они будут думать, что этот элемент никуда не ушел и ничего не изменилось.</b></p>

<h3>Absolute Positioning</h3>
<p>Все смещения (offsets) – top, bottom, left, right – относительны положения <b>ближайщего родителя, который имеет position отличный от static.</b></p>
<p>По умолчанию <b>html</b> – это единственный элемент, который имеет non-static позиционирование, а именно <b>relative</b>.</p>
<p>Элемент с position: absolute <b>вынимается из normal doc flow.</b> Таким образом, элементы вокруг него думают, что этот элемент исчез, и <b>смещаются исходя из этого</b>.</p>
<p><b>p { position: absolute; bottom: 10px; right: 10px; }</b> означает, что элемент сместится на 10px снизу вверх и на 10px справа налево от границ его родительского элемента, position которого non-static. Если такого элемента нет, то он сместится от элемента < html >, так как он relative.</p>
<p>В комбинации <b>relative контейнер</b> + любой элемент, если сместить этот контейнер, все элементы внутри этого контейнера <b>сместятся вместе с ним.</b></p>

<h3>Пример: Relative</h3>
<p>Элемент 1 не был вытащен из document flow, так как после его перемещения остальные коробки не сместились на его место – они думают, что он все еще там.</p>
<div class="blue-cont">
	<p class="rel one"></p>
	<p class="rel two"></p>
	<p class="rel three"></p>
	<p class="rel four"></p>
</div>

<h3>Пример: Absolute</h3>
<p>Элемент 3 был вытащен из document flow. Если бы у голубого контейнера не был задан no-static position, зеленый квадрат бы сместился на top: 0 и left: 0 относительно всего документа или др. ближайщего родительского контейнера. В данном случае он бы был в самом верхнем левом углу всей страницы. Так как для голубого прямоугольника задан position: relative (также подойдет absolute), т.е. no-static, он сместился в верхний левый угол этого контейнера. Также relative контйнер был смещена на 15px сверху, и весь контент (relative, absolute, static) <b>сместился вместе с ним</b>.</p>
<div class="blue-cont">
	<p class="rel one"></p>
	<p class="rel two"></p>
	<p class="rel abs three"></p>
	<p class="rel four"></p>
</div>

<h2>Media Queries – Медиа запросы</h2>
<p>Позволяют группировать стили вместе и таргетировать их на устройства на основе некоторых критериев. Например, <b>по ширине, высоте или ориентации (ландскейп или портрет).</b></p>
<h3>Media Query Syntax</h3>

<p>@media (max-width: 767px) { <br>
	p { <br>
		color: blue; <br>
	} <br>
} <br>
</p>

<p><b>(max-width: 767px)</b> – Media Feature (resolves to true or false). Если true, стиль применится. Если false – нет.</p>
<p><b>Можно объединить несколько функций мультимедиа (media features) с помощью логических операторов.</b></p>

<h3>Media Query Common Features</h3>
<p>@media (max-width: 800px) {...} <br>
@media (min-width: 800px) {...} <br>
@media (orientation: portrait) {...} <br>
@media (screen) {...} <br>
@media (print) {...} <br>
</p>
<p>Наиболее распространенным способом таргетинка на разные устройства является <b>их ширина</b>.</p>

<h3>Medai Query Common Logical Operations</h3>
<p>Объединение с помощью логических операторов:</p>

<h4>Devices with width within a range</h4>
<p>@media (min-width: 768px) and (max-width: 991px) {...}</p>

<h4>Comma is equivalent to OR</h4>
<p>@media (max-width: 767px), (min-width: 998px) {...}</p>
<p>Таргет на любые устройства меньше 767px или больше 998px.</p>

<h4>Comma is equivalent to OR</h4>
<p>@media (max-width: 767px), (min-width: 998px) {...}</p>

<h3>Media Query Common Approach</h3>
<p><ol>
	<li>Сначала начать с базовых стилей, которые будут применены ко всем экранам/ориенациям и т.д.</li>
	<li>Затем начать нацеливаться на определенный размер экрана, либо изменяя некоторые свойства базовых стилей, либо добавляя что-то еще к ним, либо что-то отнимая</li>
	<li>Границы диапазона не должны перекрываться: если я в одном @media использую ограничение 1200px, то в другом это дожно быть 1199px или 1201px, в противном случае оба набора стилей будут применены и все будет очень грязным</li>
</ol></p> <br>
<p>Брать диапазоны размеров для широких, средних и прочих экранов можно из <b>стандартных диапазонов, которые структура Twitter Bootstrap определяет для своих различных media device sizes</b>.</p><br>

<p>В окне просмотра кода в Google Chrome, можно показать Medai Queries. Для этого надо активировать <b>Toggle Device Toolbar, нажать на три вертикальных точки и выбрать Show Media Queries</b>.</p><br>
<p>Точки разрыва между разными диапазонами Media Queries называются <b>Break Points</b>.</p>

<h2>Responsive Design</h2>
<p>Это дизайн, предназначенный для адаптации своего лэйаута к среде просмотра, используя <b>fluid, proportion-based grids (ширина должна быть указана в %), flexible imges и CSS3 media queries.</b></p>
<p>Контент должен адаптироваться под ширину экрана (чаще всего), при этом <b>многословность контента или его visual delivery могут измениться</b>. Например, номер телефона, который в декстопной версии не привлекал к себе особого внимания и находился где-то в углу, в мобильной версии является центральным элементом и он самый заметный.</p>
<p><b>Некоторые части сайта могут быть скрыты в мобильной версии вообще.</b></p>

<h3>Alternative to Responsive Design:</h3>
<p>Можно иметь сервер высокой технологии, который обнаруживает User-Agent (тип браузера, который используется) и с помощью этого выяснять, находится человек на мобильном или декстопном устройстве, а затем на основе этой инфы либо обслуживать обычную декстопную версию (www.site.com), либо предоставить клиенту мобильную версию сайта (m.site.com).</p>
<h4>Проблемы такого подхода:</h4>
<p>1. Высокий риск перенаправления функций между приложениями, потому что технически это два разных приложения, работающих на моем сайте. <br> 2. Мобильные устройства слишком разнообразны между собой. Поэтому трудно сделать мобильный сайт, который удовлетворит каждого клиента. Поэтому часто приходится жертвовать UX, чтобы создать один мобильный сайт, который подходит всем.</p>

<h3>12-Column Gird Responsive Layout</h3>
<p>Самый распространенный layout – это 12-колонный сетчатый макет. <b>Его использует Twitter Bootstrap и почти каждый другой отзывчивый фреймворк</b>.</p>
<p>Он используется из-за <b>factors of 12: 1, 2, 3, 4, 6, 12</b>. Число 12 на это все красиво делится. Это означает, что<b> можно разделить страницу на разделы, которые равномерно разбиты и красиво layout themselves</b>.</p>
<p>Например, можно иметь контент, который 4 раза делится на 3 столбца. Либо поделить макет на 6 + 6. Или 4 + 4 + 4. <br> Комбинация также может быть асиметричная: 8 + 4 или 9 + 3 и так далее.</p>
<p>Таким образом, если ширина браузера  100%, значит <b>1 column (столбец) = 100% / 12 = 8.33%</b>.</p>

<h4>Как делится все остальное:</h4>
<p>3 + 3 + 3 + 3 = по 25% <br>
6 + 6 = по 50% <br>
4 + 4 + 4 = по 33.33% <br>
и так далее</p>

<h4>Nested Grids (Вложенные сетки)</h4>
<img src="nested-grids.png">
<p>Если у нас есть 4 + 4 + 4, каждый из них <b>можно рассмотреть как 100% и вложить в них другие комбинации:</b> 6+6, 3+3+3+3, 4+4+4 и так далее.</p> <br>

<p>Чтобы центрировать что-то внутри block-element'a div, можно использовать этот трюк: <br>
margin-right: auto;<br>
margin-left: autro;</p>

<h3>Responsive Layout Example</h3>
<p>Это отображается не не весь экран, потому что у тега body есть margin</p>
<div class="row">
  <div class="col-lg-3 col-md-6"><p class="resp">Item 1</p></div>
  <div class="col-lg-3 col-md-6"><p class="resp">Item 2</p></div>
  <div class="col-lg-3 col-md-6"><p class="resp">Item 3</p></div>
  <div class="col-lg-3 col-md-6"><p class="resp">Item 4</p></div>

  <div class="col-lg-3 col-md-6"><p class="resp">Item 5</p></div>
  <div class="col-lg-3 col-md-6"><p class="resp">Item 6</p></div>
  <div class="col-lg-3 col-md-6"><p class="resp">Item 7</p></div>
  <div class="col-lg-3 col-md-6"><p class="resp">Item 8</p></div>
</div>

<h3>Мобильные версии</h3>
<p>По умолчанию мобильные версии <b>пытаются уменьшить (zoom out) все содержимое сайта со 100% до 40% (например)</b>, если им не говорят делать что-то другое. Поэтому они могут попытаться вписать весь контент в окно просмотра телефона.</p>
<p>Чтобы сказать мобильному браузеру, что это на самом деле отзывчивый дизайн, и не нужно пытаться zoom out его масштаб, просто оставайся на регулярном уровне масштабирования, надо указать специальный метатег в head: <br>
<b> < meta name="viewport" content="width=device-width, initial-scale=1" ></b></p>
</html>