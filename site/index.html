<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<title>Coursera is cool</title>
	<style type="text/css">
		
		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body {
			font-family: arial;
			margin: 40px 150px;
			line-height: 1.5;
		}
		table {
			border-collapse: collapse; /*Убирает отсутпы между ячейками таблицы*/
		}
		td, th {
			padding: 10px;
			border: 1px solid black;
		}
		img {
			width: 70%;
		}
		table.center {
			text-align: center;
		}
		#float {
			background: lightblue;
		}
		#float-group p {
			float: left;
			width: 50px;
			height: 50px;
			border: 1px solid black;
			margin-left: 10px;
		}
		#p1 {
			background-color:  red;
		}
		#p2 {
			background-color:  blue;
		}
		#p3 {
			background-color:  green;
			clear: left;
		}
		#p4 {
			background-color:  yellow;
		}
		#float-section {
			clear: left;
			margin-left: 10px;
		}
		#two-column {
			background-color: skyblue;
		}
		#p5, #p6 {
			width: 50%;
			border: 1px solid black;
			float: left;
			padding: 20px;
		}
		#p5 {
			background-color: red;
		}
		#p6 {
			background-color: green;
		}
		h1, h2, h3, h4 {
			margin-top: 40px;
			margin-bottom: 15px;
		}
		.blue-cont {
			background-color: lightblue;
			position: relative;
			top: 15px;
		}
		.rel {
			width: 50px;
			height: 50px;
			border: 1px solid black;
			margin-bottom: 15px;
		}
		.rel.one {
			background-color: red;
			position: relative;
			top: 65px;
			left: 65px;
		}
		.rel.two {
			background-color: blue;
		}
		.rel.three {
			background-color: green;
		}
		.rel.four {
			background-color: yellow;
		}
		.rel.abs.three {
			position: absolute;
			top: 0;
			left: 0;
		}
	</style>
</head>
<body>
<h1>Coursera: HTML + CSS + JS</h1>
<p id="section1">Всегда используйте языковой атрибут <b>lang</b> тэга html для объявления языка по умолчанию на странице. Если страница содержит контент на другом языке, добавляйте языковой атрибут к элементам, окружающим этот контент. </p>
<p>Все элементы можно поделить на 2 категории: <b>Block-level elements</b> и <b>Inline Elements</b>.</p>
<table style="text-align: left;">
	<tr>
    <th>Block-level elements</th>
    <th>Inline Elements</th>
   </tr>
   <tr><td style="padding-right: 30px;" width="400px">Отображаются, начиная с новой строки (по умолчанию, можно изменить в CSS)</td><td>Отображаются на одной строке (по умолчанию).</td></tr>
   <tr><td style="padding-right: 30px;" width="400px">Могут содержать в себе inline elements или другие block-level elements.</td><td>Могут содержать в себе только другие inline-elements</td></tr>
   <tr><td style="padding-right: 30px;" width="400px">Roughly Flow Content (HTML5 Category)</td><td>Roughly Phrasing Content (HTML5 Category)</td></tr>
</table>
<br>
<div>Div – деление. Самый общий block элемент. Он не может быть вложен в span</div>
<div>Div – Самый общий block элемент. Он требует своей собственной строки.</div>
<span>Span – диапозон, интервал. Самый общий inline элемент. Если он идет после div, то все равно перенесется на новую строку, как тут.</span>
<div>
	** Вот что будет, если поместить span внутри div: **
	<span>** Это текст внутри span, он идет в строку **</span>
	** Это текст после span, который просто внутри div. **
</div>
<br>
<div><a href="https://www.w3.org/TR/2011/WD-html5-20110525/content-models.html">По данной ссылке</a> можно посмотреть разные категории моделей содержимого HTML5. Например: <img src="/Users/panteleymon/coursera-test/site/content.png" width="70%"></div>
<br>
<h2><a name="section2">Semantic tags</a></h2>
<div><b>Semantic Tags</b> – это то, что помогает SEO. Например <b>h1-h6</b> элементы. Если не использовать заголовки, а использовать div, то потеряется смысл заголовка. H1 должен передавать центральную тему основного содежрания и он очень важен для SEO оптимизации. Правильно подобранный контент для этого тега может играть решающее значение.</div>
<br>
<div><b>Header тег</b> содержит инфу о содержании страницы: лого компании, теги, навигация
<br><b>Nav</b> означает содежимое, использующееся для навигации внутри сайта
<br>Есть также <b>Section</b> и <b>Article</b>, которые могут вкладываться друг в друга
<br><b>Aside тег</b> означает содержание, которое относится к содержимому главной темы, но не как прямая связь, например, related posts.
<br><b>Footer тег</b> имеет инфу нижнего колонтитула. Copyright и т.д.</div>
<br>
<div>Это все элементы <b>block level</b>, кроме <b>nav</b>.</div>
<div>Вместо всех этих тегов легко можно было бы использовать div, но код с разнообразными тегами легче читать и понимать, что происходит на структурной основе HTML страницы. Их использование может повлиять как на SEO ranking of the page, так и на понимание страницы не только людьми, но и компьютерами.</div><br>
<p>Lists позволяют группировать контент. Часто используются для структурирования навигационных частей страницы. <b>ul</b> - unordered list. <b>ol</b> - ordered list. <b>li</b> - list item.</p>
<div>
	<ul>
		<li>Молоко</li>
		<li>Пончики</li>
		<li>Печеньки
			<ul> <!-- Подпсписок -->
				<li>Шоколад</li>
				<li>Сахар</li>
			</ul>
		</li>
		<li>Картошка</li>
	</ul>

	<ol>
		<li>Откртыть печеньки</li>
		<li>Достать их</li>
		<li>Сложить их вместе
			<ol> <!-- Подпсписок -->
				<li>Снять верхнюю часть</li>
				<li>Положить на нее другую печеньку</li>
			</ol>
		</li>
		<li>Съесть это</li>
	</ol>
</div>
<h2>
	HTML Character Entity References
</h2>
<p>These 3 characters should always be escaped: "<", ">", "&".</p>
<table><tr>
   <tr><td><b>Вместо этого</b></td><td><</td><td>></td><td>&</td></tr>
   <tr><td><b>Использовать это (см. код)</b></td><td>&lt;</td><td>&gt;</td><td>&amp;</td></tr>
<p>Это позволит браузеру интерпретировать символы не как код, а как контент.</p>
</table>
<p>Copiright можно записать кодом как &copy; (см. код)<br>
Неразрываемы&nbsp;пробел&nbsp;записывается&nbsp;так (см. код). Non-broken space – nbsp. С помощью него также можно создавать несколько&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;пробелов, но это <b>неправильно</b>. Вместо этого надо применять margin в css.</p>
<p>" можно заменить с помощью &quot;. quot помогает, если при ограниченной кодировке (не utf-8, а другой) кавычки заменяются странными символами.</p>
<h2>Creating links</h2>
<p id="section 1">Есть внутренние и внешние ссылки. Ссылки делаются с помощью тега "а". Значение его атрибута href может быть как относительным, так и абсолютным URL адресом. Для внутренних ссылок можно использовать и относительные URL ссылки (same-directory.html), и абсолютные (https://www.facebook.com/). Если не представить информации о директории относительной ссылки, браузер будет считать, что она расположена там же, где и основной документ. Также лучше указывать атрибут <b>Title</b> для тега "а", они используются скринридерами и помогают людям с нарушениями зрения изучать страницу.</p>
<p>В тег "a" может быть заключен div. Это нужно, чтобы иметь возможность кликнуть по целому региону (лого и пр.), а не надписи. Он также по умолчанию заставит контент перейти на новую строку.</p>
<p>Внешние ссылки часто включают атрибут 'target'. Например target="_blank" заставляет браузер открыть стр. в новом окне или вкладке.</p>
<p>Есть также тип ссылки, который является идентификатором фрагмента. Например, <b>a href="#section1"</b>. Они указывают на разделы страницы. Чтобы ими пользоваться, надо иметь раздел с <b>id="section1"</b>. Id не содержит символа #, который содержит ссылка. <br>Также это может быть якорный тег, который содержит name атрибут <b>name="section1"</b>.</p>
<div><a href="#section1">Начало документа (id)</a>
<a href="#section2">Semantic tags (якорь через name)</a></div>
<p>Такая навигация часто используется в SPA (Single Page Applications).</p>
<h2>Displaying images</h2>
<p>img tag имеет атрибут src – он также может быть относительным или абсолютным, width и height должны быть указаны обязательно, <b>иначе, браузер не забронирует это место для изображения при загрузке, и картинка будет некрасиво прыгать.</b>. А если сломается url, визуальный layout все равно сохранится, если указать width и height. img - inline element.</p>
<h2>Anatomy of a CSS Rule</h2>
<p>CSS имеет селектор (то, чему задается стиль, например p { ... 
	<br>color - property, blue - value. Stylesheet – файл со всеми этими стилями. Style можно запихнуть в head документа в теги style, но проще подключить другой документ.</p>

<h2>Element, Class, and ID Selectors</h2>
<p>Element – просто указания имени. Например, "p" <br>
Class – ".blue" в CSS и class="blue" в HTML<br>
Id – "#mainPoint" в CSS и id="mainPoint" в HTML. <b>Регистр букв имеет значение</b> <br>
Grouping Selectors: div, .blue
<br><b>Id элемент самый немногоразовый. Один и тот же ID Value может отображаться в HTML документе только 1 раз.</b></p>

<h2>Combining Selectors</h2>
<h3>Element with Class Selector</h3>
<p>Эта техника помогает нацелиться на немые элементы. Например, "p" с class селектором: <br> p.big { <br>
font-size: 20px; <br>
}</p>
<p>Если я поставлю пробел между p.big, это будет означать уже другую комбинацию, а не каждый p с классом big.</p>
<h3>Child Selector</h3>
<p>article > p {<br> color: blue; <br> }</p>
<p>Эта комбинация читается справа налево. Это означает таргет на каждый "p", который является прямым (direct) дочерним элментом "article". <br> Например, текст в < article >< p >< div > ... < /div >< /p >< article > не будет синим, потому что здесь текст не в прямом дочернем элементе, а в div. </p>
<h3>Descendant (Поточный) Selector</h3>
<p>article p { <br> color: blue;<br>}</p>
<p>Комбинация также читается справа налево. Означает таргет на каждый "p", который находится внутри "article" <b>на любом уровне</b>. Таким образом, ему необязательно быть direct chield.</p>
<h3>Not Limited to Element Selectors</h3>
<p>Селекторы никак не ограничены и может быть много комбинаций, например:</p>
<p>.colored p { <br>color: blue; <br>}</p>
<p>Читается справа налево. Означает, что каждый "p" элемент, который находится на любом уровне элемента с class="colored", будет иметь голубой цвет.</p>
<br>
<p>article > .colored { <br>color: blue; <br>}</p>
<p>Читается справа налево. Означает, что каждый элемент с class="colored", который является прямым дочерним элементом элемента "aricle", будет иметь голубой цвет.</p>
<h3>Применение нескольких классов к элементу</h3>
<p>Чтобы применить несколько классов к одному элементу, нужно просто написать их через пробел без запятых: <b>div class="mainpoint highlight"</b></p>

<h3>Стили для нескольких классов</h3>
<p>.highlight.mainpoint { <br>color: red; <br>}</p>
<p>Это пишется без пробела, стиль применится к тому элементу, который имеет <b>оба класса</b> (не каждый по отдельности).</p>

<h3>Adjacent Sibling Selector (Смежные селекторы)</h3>
<p>li:first-of-type + li { <br>
  color: red; <br>
}</p>
<p>Указывает на смежный или следующий селектор. Обеспечивает выбор только элемента расположенного непосредственно за определённым в первой части элементом.</p>
<p>Таким образом, в коде <br>
< ul ><br>
  < li >Один< /li ><br>
  < li >Два< /li ><br>
  < li >Три< /li ><br>
< /ul ><br>
красным будет только "Два".
<p><ul>
  <li>Один</li>
  <li style="color: red;">Два</li>
  <li>Три</li>
</ul>
</p>
</p>
<h3>General Sibling Selector (Селектор следующего элемента)</h3>
<p>p ~ span { <br>
  color: red; <br>
}</p>
<p>Разделяет 2 селектора и находит 2-й элемент только если перед ним есть 1-й, и они оба имеют общего родителя. Свойства будут применены ко всем элементам, указанным в правой части, следующими за элементом, указанным в левой части.</p>
<p>
< span >Это не красный.< /span > <br>
< p >Здесь параграф.< /p > <br>
< code >Тут какой-то код.< /code ><br>
< span > <span style="color: red;"> А здесь красный, потому что он идет после "p". </span>< /span >
</p>

<h2>Pseudo-Class Selectors</h2>
<p>Примеры псевдо-класс селекторов: <br>
:link (стиль ссылки), :visited (стиль посещенной ссылки), :hover (наведение), :active (нажато, но еще не отпущено), :nth-child(...) и прочие</p>
<p>Не по теме: block элементы по умполчанию заполняют все пространство в строке, которое они могут заполнить. Поэтому если сделать им background-color, он заполнит всю строку.</p>
<p>nth-chlid(...) позволяет таргетироваться на конкретный элеменент по номеру, например: <br> <br>
header li:nth-chlid(3) { <br>
color: red; <br>
}</p>
<p><b>section div:nth-chlid(odd)</b> будет таргетироваться только на нечетные пункты div</p>
<p>Псевдо-селекторы могут быть комбинированы, как и обычные селекторы. Например: <br>
<b>section div:nth-child(4):hover</b> будет таргетироваться только на 4-й div при наведении</p>
<p>a:hover div:nth-child(5) {  <br>
  font-size: 24px; <br>
} <br>
Данный код будет менять размер шрифта Div 5, когда мышь наведена <b>на любую зону "a" элемента.</b></p>
<h2>Style Placement</h2>
<p>В head, непосредственно в элементе (inline styling), внешние таблицы стилей: <br>
< link rel="stylesheet" href="style.css" > <br>
stylesheet должен располагаться <b>в той же директории, что и index.html файл.</b></p>
<h2>Conflict Resolution</h2>
<h3>Some Concepts</h3>
<table>
	<tr>
    <th>origin</th>
    <th>merge</th>
   </tr>
   	<tr>
    <th>inheritance</th>
    <th>specificity</th>
   </tr>
</table>
<h3>Origin Precedence – Приоритет происхождения (when in conflict)</h3>
<p><b>Правило:</b> Последнее объявление выигрывает. Так как HTML отображается последовательно сверху вниз, так что <b>чем ниже код на странице, тем больше их приоритет.</b> Если это внешний CSS, то надо просто представить, что он взят и полностью скопирован в head, то есть он вверху.</p>

<h3>Merge (when no conflict)</h3>
<p>Если на один элемент нацелены разные CSS свойства (например, цвет и размер) из разных источников, то они просто сольются в один, т.к. конфликта нет.</p>

 <h3>Inheritance – Наследование</h3>
 <p>Есть Document Object Model (DOM) Tree, в котором все дети и дети этих детей заданного элемента будут наследовать свойства этого элемента.</p>
 <img src="dom-tree.png">

 <h3>Specificity</h3>
 <p><b>Правило:</b> Наиболее специфическая комбинация селекторов выигрывает.</p>
<div>Таким образом, селекторы с наибольшим счетом считаются более конкретными (слева направо – самые специфичные к менее специфичным). <br> Чтобы посчитать счет, надо взять код и посмотреть сколько раз определенный селектор используется в правильном месте. <br><br>
<table class="center">
	<tr>
		<td>style="..."</td><td>ID</td><td>Class, pseudo-class, attribute</td><td># (потомки) of Elements</td>
	</tr>

	<tr><td colspan="4">< h2 style="color: green; ></td></tr>
	<tr><td>1</td><td>0</td><td>0</td><td>0</td></tr>

	<tr><td colspan="4">div p { color: green; }</td></tr>
	<tr><td>0</td><td>0</td><td>0</td><td>2</td></tr>

	<tr><td colspan="4"><b>Кто победит?</b></td></tr>
	<tr><td colspan="4">div #myParag { color: blue; }</td></tr>
	<tr><td>0</td><td>1</td><td>0</td><td>1</td></tr>
	<tr><td colspan="4">Итого счет 101</td></tr>
	<tr><td colspan="4">div.big p { color: green; }</td></tr>
	<tr><td>0</td><td>0</td><td>1</td><td>2</td></tr>
	<tr><td colspan="4">Итого счет 12</td></tr>
	<tr><td colspan="4"><b>Победил синий цвет</b></td></tr>
</table><br>
<b>Для этой победы можно было не конкретизировать код с помощью div, а обойтись только #myParag</b>
</div>
<p>Предопределить все эти правила помогает <b>!important</b>. Даже если у применяемого правила всего одно очко, оно выиграет с этим обозначением. Но использовать это нужно <b>в крайнем случае, когда без этого не обойтись</b></p>
<h2>Styling Text</h2>
<p>Причина, по которой я в <b>font-family</b> указываю не только один шрифт, а несколько, заключается в в том, что когда я указываю семейство шрифтов таким образом, я полагаюсь на компьютер пользователя и на то, что <b>на нем установлены это шрифты</b>. И таким образом я предоставляю несколько опций.</p>
<p> p { font-family: "Times New Roman", Times, serif; }</p>
<p>В коде цвета <b>#0000ff</b> первые 2 цифры - red, вторые 2 – green, третие 2 – blue. <b>ff – самое высокое значение</b>.</p>
<p>Почти каждый браузер имеет размер шрифта по умолчанию <b>16 px</b>.</p>
<h3>Relative Font Sizing</h3>
<p><b>font-size: 120%</b> означает, что надо взять размер шрифта, который бразуер предоставляет по умолчанию (16px, например), и увеличить его на 120%. То есть это будет немного больше 19px. <b>Часто % применяется ко всему документу, т.е. к тегу body.</b></p>
<p><b>font-size: 2em</b> – em – это единица измерения, которая эквивалентна ширине буквы "m" в этом конкретном шрифте. <b>Это относительный размер</b>. И если комбинировать его со 120%, которые были заданы родительскому тегу, то мы <b>увеличим шрифт в 2 раза от того, что было 120%</b>. То есть 120% не переопределяет 2em, а играет вместе с ним, потому что 2em относительный. То же самое em сделает с px, несмотря на то, что они – абсолютные. А если я хочу сделать дочерний 2em тег размером 4em, мне нужно прописать в нем также 2em, потому что они умножатся. Технически 2em = 200%. Однако более распространенная практика – это использование именно em внутри самих документов, а не тега body.</p>
<p>Если я хочу уменьшить 4em до 2em, в могу ввести в дочернем теге <b>.5em</b>, что уменьшит его в 2 раза.</p>
<p>Несмотря на то, что % используются в body, <b>не рекомендуется смешивать %, em и px в документах</b>, иначе будет беспорядок.</p>
<p>Несмотря на то, что  120% размер текста указан в body, <b>пользователь может сделать то же самое, просто увеличив масштаб</b>. При этом визуальные отношения размеров шрифтов (если они были указаны относительными единицами), <b>останутся теми же</b>.</p>

<h2>The Box Model</h2>
<p>В HTML каждый элемент считается коробкой. У каждой коробки есть (в таком порядке): padding, border, margin.</p>
<p>По умолчанию браузеры часто ставят тегу body какой-то margin, но его можно сбрасывать, если нужно.</p>
<p>В записи margin: 10px 10px 10px 10px значения идут начиная сверху по часовой стрелке: верх, право, низ, лево.</p>
<p><b>Padding</b> дает некоторое заполнение вокруг контента, которое также примет значения этого контента, например, цвет. Потому что это буквально расширяет поле контента.</p>
<p><b>Border</b> будет идти вокруг padding, т.е. вокруг контента.</p>
<p><b>Margin</b> дает отступы вокруг всего контента вместе с padding и border.</p>
<p>Если у контента с width 300px указать padding 10px с каждой стороны + border 5 px с каждой стороны, получится коробка шириной 330px. Таким образом, <b>width – это свойство только контента, а не всей коробки</b>.</p>
<p>Однако существует <b>box-sizing: border-box, который говорит, что вся коробка должна принять свойство width</b>.</p>
<p>Чтобы вернуть все к значению по умолчанию, надо поставить <b>box-sizing: content-box</b>.</p>
<p style="color: red;"><b>Современные фреймворки, например, Bootstrap, используют border-box как sizing model.</b> Поэтому когда я работаю со своими макетами, мне также надо установить везде border-box. Но это свойство не наследуется. Чтобы обойти это, надо установить star selector:</p>
<p>* { box-sizing: border-box; } </p>
<p>* говорит коду идти и применить эти свойства к каждому элементу, который у нас есть. Ее отличие от родительского селектора, например, body, в том, что * <b>не просит наследовать что-либо</b>, а говорит применить свойства к каждому элементу, будто бы они были в них вписаны вручную.</p><br>
<h3>caniuse.com</h3>
<div>Сайт, на котором можно проверять, все ли браузеры поддерживают какие-либо свойства.</div> <br>

<h3>Cumulative Margins (Кумулятивные)</h3>
<p>Поля <b>слева направо</b> являются кумулятивными. Это значит, что они складываются и играют вместе. То есть если у двух коробок в одной линии стоит margin left 40px и margin right 50px, между ними будет margin = 90px.</p>
<h3>Margins Collapse</h3>
<p><b>Верхние и нижние поля</b> не являются кумулятивными, и они схлопнуться, и крупнейшая маржа победит. То есть если margin bottom 20px и margin top 30px, то маржа между двумя коробками друг над другом будет просто 30px.</p>

<h3>Изначальные установки браузера</h3>
<p>Помимо простого margin, бразуер может предопределять <b>-webkit-margin-before и -webkit-margin-after</b>, которые не обнуляться, если в body установить значение margin: 0. Потому что в таком случае body говорит, что все элементы будут наследовать это свойство в том случае, если для какого-то элемента оно не будет специально переопределено. Таким образом, если margin-before или margin-after были указаны специально для селектора h1, они не обнулятся. <b>Таким образом, margin: 0 можно просто записать в star selector ( * ).</b> Это называется CSS Resetting (сброс настроек CSS по умолчанию), и в основном для этого всегда используется * selector.</p>
<p>Если при box-sizing: border-box указать height, который меньше высоты контента, контент просто "вытечет" из коробки. С этим поможет справиться <b>overflow</b>. При свойстве <b>hidden</b> контент просто будет обрезаться там, где заканчивается коробка. <b>Visible</b> – это свойство по умолчанию, когда он вытекает. <b>Auto</b> – скрыть и проложить scrollbars везде, где они нужны, чтобы можно было посмотреть весь контент. <b>Scroll</b> позволят держать ползунки прокрутки видимыми вне зависимости от того, нужны они или нет (в том числе горизонтальный скролл, даже если он не нужен).</p>
<p><b style="color: red;">НО! Пользователи ненавидят двойную прокрутку. Использовать это только там, где реально необходимо.</b></p>

<h2>The background Property</h2>
<p><b>background-image: url("image.png")</b> – так сделать фон картинку. Важно: url должен быть относителен файлу CSS и тому, как CSS подается в браузере.</p>
<p><b>background-repeat: no-repeat</b> или другие свойства позволяют контролировать повторяется изображение в данной области или нет.</p>
<p>background-image и backgrpund-color могут использоваться вместе и background-image будет выигрывать в приоритете: он будет вверху.</p>
<p><b>background-position: top right</b> – позиция фонового изображения в формате горизонтального + вертикального значения. Если указать только один из них, другой по дефолту будет считаться центром.</p>
<p style="color: red;"><b>Все эти индивидуальные свойства можно объединить в одно общее:</b></p>
<p><b>background: url("image.png") no-repeat right center blue;</b> – просто надо указывать их один за другим. Если указать что-то в теге background, а что-то в теге в формате background-something, один из тегов перепишет другой (в зависимости от того, какой будет находиться ниже в коде). <b>Если при использовании тега background, который находится ниже тега в формате background-something я не укажу конкретной свойство, оно не будет зайдествовано вообще, даже если в background-something оно было задано.</b></p>

<h2>Positioning Elements by Floating</h2>
<p>Большинство UI сегодня сделаны с помощью floating elements.</p>
<p><b>floar: right</b> перемещает элемент в правый край содержащего элемента. Допустим, если 'p' находился внутри 'div', он уедет в правый верхний конец этого div. При этом элементы, которые находились под ним слева, подвинутся наверх на его исходное место. Причина в том, что когда я float элементы, <b>браузер исключает их из обычного потока документов.</b>Если у нижних элементов была маржа, она коллапснится, когда она каснется поля другого элемента. Однако у того элемента, который был floated, <b>margin никогда не разрушается.</b></p>
<p>Если все 'p' внутри одного 'div', которые изначально были расположены с новых строк друг над другом, сделать <b>float: left</b>, они будут идти в строку друг за другом, а размер контейнера div уменьшится до размера других элементов, расположенных в нем, так как <b>float элементы из него вылетят, и будут просто плавать слева от всего контента</b>.</p>
<p>Чтобы исправить это, нужно сказать браузеру, что нижний элемент внутри div не разрешает ничему плавать слева от него:</p>
<p>
	< div > <br>
	< p id="p1" >< /p ><br>
	< p id="p2" >< /p ><br>
	< p id="p3" >< /p ><br>
	< p id="p4" >< /p ><br>
	< section > Какой-то текст < /section ><br>
	< /div >
</p>
<p>p { float: left; } <br>
section { clear: left; }</p>
<p>Таким образом, свойство <b>claer: left;</b> говорит, что section должен быть под p, а не справа от них, потому что он не разрешает ничему плавать слева от него.</p>
<p><b>Пример:</b></p>
<div id="float">
	<div id="float-group">
	<p id="p1"></p>
	<p id="p2"></p>
	<p id="p3"></p>
	<p id="p4"></p>
	</div>
	<section id="float-section">Какой-то текст для примера того, как запрещать float элементам плавать слева от него</section>
</div>

<p>Таким образом, если задать clear: left третьей коробке, то она переместится на новую строку вместе с четвертой коробкой.</p>
<p><b>clear: both</b> позволяет гарантировать, что если есть два элемента, у одного из которых стоит float: left, а у другого float: right, ни один из них не посягнет на пространство элемента, у которого задан clear: both</p>

<h3>Two Column Layout Design</h3>
<div id="two-column">
<p id="p5">Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.</p>
<p id="p6">It has survived not only five centuries, but also the leap into electronic typesetting, remaining essentially unchanged. It was popularised in the 1960s with the release of Letraset sheets containing Lorem Ipsum passages, and more recently with desktop publishing software like Aldus PageMaker including versions of Lorem Ipsum.</p>

<section>Это пример дизайна с двумя колонками с помощью свойства float: left. Важно чтобы их настройки ширины были заданы таким образом, чтобы они помещались по ширине на одну строку. Иначе вторая колонка сползет вниз на новую сторку. Для этого нужно установить <b>width: 50%</b>, но если есть padding и/или border, убедиться, что <b>box-sizing: border-box</b></section>
</div>

<h2>Relative and Absolute Element Positioning</h2>
<h3>Static Positioning</h3>
<p>Normal doc flow. Default for all, except html.</p>
<p>Если попытаться применить смещения позиционирования к элементам, чей position: static, <b>смещения просто будут игнорироваться.</b></p>

<h3>Relative Positioning</h3>
<p>Relative to element's position in normal doc flow.</p>
<p>Если применить смещение (offset) к этому элементу, произойдет смещение <b>от исходной нормальной позиции элемента в потоке документа.</b></p>
<h4>Positioning CSS (offset) properties are:</h4>
<p>top, bottom, left, right</p>
<p>Таким образом, границы элемента сверху, снизу, слева и справа становятся <b>границами, от которых я смещаю элемент</b>.</p>
<p>Элемент, который установлен на relative position <b>не вынимается из нормального потока документов.</b> Даже если он перемещается с помощью смещений, его <b>original spot сохраняется.</b> То есть относительно всех осталньых элементов HTML, этот элемент все еще сидит на своем первоначальном месте, хотя визуально он где-то в другом месте.</p>
<p><b>p { position: relative; top: 50px; left: 50px; }</b> будет означать, что сверху вниз элемент сместится на 50px и слева направо на 50px от своего изначального положения в документе. При этом фактически его изначальное место в документе будет все еще закреплено за ним. Таким образом, <b>все элементы вокруг этого элемента останутся на своих местах, потому что они будут думать, что этот элемент никуда не ушел и ничего не изменилось.</b></p>

<h3>Absolute Positioning</h3>
<p>Все смещения (offsets) – top, bottom, left, right – относительны положения <b>ближайщего родителя, который имеет position отличный от static.</b></p>
<p>По умолчанию <b>html</b> – это единственный элемент, который имеет non-static позиционирование, а именно <b>relative</b>.</p>
<p>Элемент с position: absolute <b>вынимается из normal doc flow.</b> Таким образом, элементы вокруг него думают, что этот элемент исчез, и <b>смещаются исходя из этого</b>.</p>
<p><b>p { position: absolute; bottom: 10px; right: 10px; }</b> означает, что элемент сместится на 10px снизу вверх и на 10px справа налево от границ его родительского элемента, position которого non-static. Если такого элемента нет, то он сместится от элемента < html >, так как он relative.</p>
<p>В комбинации <b>relative контейнер</b> + любой элемент, если сместить этот контейнер, все элементы внутри этого контейнера <b>сместятся вместе с ним.</b></p>

<h3>Пример: Relative</h3>
<p>Элемент 1 не был вытащен из document flow, так как после его перемещения остальные коробки не сместились на его место – они думают, что он все еще там.</p>
<div class="blue-cont">
	<p class="rel one"></p>
	<p class="rel two"></p>
	<p class="rel three"></p>
	<p class="rel four"></p>
</div>

<h3>Пример: Absolute</h3>
<p>Элемент 3 был вытащен из document flow. Если бы у голубого контейнера не был задан no-static position, зеленый квадрат бы сместился на top: 0 и left: 0 относительно всего документа или др. ближайщего родительского контейнера. В данном случае он бы был в самом верхнем левом углу всей страницы. Так как для голубого прямоугольника задан position: relative (также подойдет absolute), т.е. no-static, он сместился в верхний левый угол этого контейнера. Также relative контйнер был смещена на 15px сверху, и весь контент (relative, absolute, static) <b>сместился вместе с ним</b>.</p>
<div class="blue-cont">
	<p class="rel one"></p>
	<p class="rel two"></p>
	<p class="rel abs three"></p>
	<p class="rel four"></p>
</div>
sublin
</html>